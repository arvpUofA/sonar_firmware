/*
 * UAVCAN data structure definition for libcanard.
 *
 * Autogenerated, do not edit.
 *
 * Source file: /home/isthatme/Documents/Clubs/ARVP/sonar_firmware/dsdl/uavcan/tunnel/63.Call.uavcan
 */

#ifndef __UAVCAN_TUNNEL_CALL
#define __UAVCAN_TUNNEL_CALL

#include <stdint.h>
#include "canard.h"

#ifdef __cplusplus
extern "C"
{
#endif

#include <uavcan/tunnel/Protocol.h>

/******************************* Source text **********************************
#
# This service carries arbitrary data in the format of the specified high-level protocol.
# The data will be delivered to the specified node only (not broadcast), and the addressed node
# will be required to respond (although the response may be empty, if the chosen protocol allows so).
# The specified protocol applies both to the request and to the response. The channelID allows for
# additional routing between the source and target nodes.
#

Protocol protocol
uint8 channel_id

uint8[<=60] buffer    # TAO rules apply

---

uint8[<=60] buffer    # TAO rules apply
******************************************************************************/

/********************* DSDL signature source definition ***********************
uavcan.tunnel.Call
uavcan.tunnel.Protocol protocol
saturated uint8 channel_id
saturated uint8[<=60] buffer
---
saturated uint8[<=60] buffer
******************************************************************************/

#define UAVCAN_TUNNEL_CALL_ID                              63
#define UAVCAN_TUNNEL_CALL_NAME                            "uavcan.tunnel.Call"
#define UAVCAN_TUNNEL_CALL_SIGNATURE                       (0xDB11EDC510502658ULL)

#define UAVCAN_TUNNEL_CALL_REQUEST_MAX_SIZE                ((502 + 7)/8)

// Constants

#define UAVCAN_TUNNEL_CALL_REQUEST_BUFFER_MAX_LENGTH                                     60

typedef struct
{
    // FieldTypes
    uavcan_tunnel_Protocol protocol;                      //
    uint8_t    channel_id;                    // bit len 8
    struct
    {
        uint8_t    len;                       // Dynamic array length
        uint8_t*   data;                      // Dynamic Array 8bit[60] max items
    } buffer;

} uavcan_tunnel_CallRequest;

extern
uint32_t uavcan_tunnel_CallRequest_encode(uavcan_tunnel_CallRequest* source, void* msg_buf);

extern
int32_t uavcan_tunnel_CallRequest_decode(const CanardRxTransfer* transfer, uint16_t payload_len, uavcan_tunnel_CallRequest* dest, uint8_t** dyn_arr_buf);

extern
uint32_t uavcan_tunnel_CallRequest_encode_internal(uavcan_tunnel_CallRequest* source, void* msg_buf, uint32_t offset, uint8_t root_item);

extern
int32_t uavcan_tunnel_CallRequest_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, uavcan_tunnel_CallRequest* dest, uint8_t** dyn_arr_buf, int32_t offset);

#define UAVCAN_TUNNEL_CALL_RESPONSE_MAX_SIZE               ((486 + 7)/8)

// Constants

#define UAVCAN_TUNNEL_CALL_RESPONSE_BUFFER_MAX_LENGTH                                    60

typedef struct
{
    // FieldTypes
    struct
    {
        uint8_t    len;                       // Dynamic array length
        uint8_t*   data;                      // Dynamic Array 8bit[60] max items
    } buffer;

} uavcan_tunnel_CallResponse;

extern
uint32_t uavcan_tunnel_CallResponse_encode(uavcan_tunnel_CallResponse* source, void* msg_buf);

extern
int32_t uavcan_tunnel_CallResponse_decode(const CanardRxTransfer* transfer, uint16_t payload_len, uavcan_tunnel_CallResponse* dest, uint8_t** dyn_arr_buf);

extern
uint32_t uavcan_tunnel_CallResponse_encode_internal(uavcan_tunnel_CallResponse* source, void* msg_buf, uint32_t offset, uint8_t root_item);

extern
int32_t uavcan_tunnel_CallResponse_decode_internal(const CanardRxTransfer* transfer, uint16_t payload_len, uavcan_tunnel_CallResponse* dest, uint8_t** dyn_arr_buf, int32_t offset);

#ifdef __cplusplus
} // extern "C"
#endif
#endif // __UAVCAN_TUNNEL_CALL